generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==========================================
// ENUMS
// ==========================================

enum UserRole {
  USER
  ADMIN
  MODERATOR
}

enum VerificationLevel {
  NONE
  EMAIL
  PHONE
  ID
  BACKGROUND
}

enum Gender {
  MALE
  FEMALE
  NON_BINARY
  PREFER_NOT_TO_SAY
}

enum GenderPreference {
  MALE_ONLY
  FEMALE_ONLY
  NON_BINARY_ONLY
  SAME_GENDER
  ANY
}

enum SleepSchedule {
  EARLY_BIRD
  MODERATE
  NIGHT_OWL
  FLEXIBLE
}

enum AccommodationStatus {
  LOOKING
  HAVE_ROOM
  NOT_NEEDED
}

enum MatchStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

enum ReportReason {
  HARASSMENT
  SPAM
  FAKE_PROFILE
  INAPPROPRIATE_CONTENT
  SCAM
  NO_SHOW
  SAFETY_CONCERN
  OTHER
}

enum ReportStatus {
  PENDING
  INVESTIGATING
  RESOLVED
  DISMISSED
}

enum AccommodationType {
  TENT
  CAMPER_VAN
  CABIN
  HOTEL_ROOM
  HOSTEL
  AIRBNB
  OTHER
}

enum EventType {
  MUSIC_FESTIVAL
  CONFERENCE
  CONCERT
  SPORTS_EVENT
  CONVENTION
  TRADE_SHOW
  CULTURAL_EVENT
  OTHER
}

// ==========================================
// USER & AUTHENTICATION
// ==========================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  role          UserRole  @default(USER)
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts      Account[]
  sessions      Session[]
  profile       UserProfile?

  eventAttendances  EventAttendance[]
  accommodations    Accommodation[]

  matchesInitiated  Match[] @relation("MatchInitiator")
  matchesReceived   Match[] @relation("MatchReceiver")

  messagesSent      Message[] @relation("MessageSender")
  threadsAsUser1    MessageThread[] @relation("ThreadUser1")
  threadsAsUser2    MessageThread[] @relation("ThreadUser2")

  blockedUsers      BlockedUser[] @relation("Blocker")
  blockedByUsers    BlockedUser[] @relation("Blocked")
  reportsSubmitted  Report[] @relation("Reporter")
  reportsReceived   Report[] @relation("Reported")
  reviewsGiven      Review[] @relation("Reviewer")
  reviewsReceived   Review[] @relation("Reviewed")
  verifications     UserVerification[]
  dealbreakers      Dealbreaker[]

  @@index([email])
  @@index([role])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ==========================================
// USER PROFILE
// ==========================================

model UserProfile {
  id                String    @id @default(cuid())
  userId            String    @unique
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  displayName       String?
  bio               String?   @db.Text
  dateOfBirth       DateTime?
  age               Int?

  gender            Gender    @default(PREFER_NOT_TO_SAY)
  genderPreference  GenderPreference @default(ANY)

  sleepSchedule     SleepSchedule @default(FLEXIBLE)
  cleanlinessLevel  Int       @default(3)
  socialLevel       Int       @default(3)
  smokingTolerance  Int       @default(3)
  drinkingTolerance Int       @default(3)

  budgetMin         Decimal?  @db.Decimal(10, 2)
  budgetMax         Decimal?  @db.Decimal(10, 2)
  budgetCurrency    String    @default("EUR")

  interests         String[]
  languages         String[]

  verificationLevel VerificationLevel @default(NONE)
  profileCompleteness Int     @default(0)

  city              String?
  country           String?
  latitude          Decimal?  @db.Decimal(10, 8)
  longitude         Decimal?  @db.Decimal(11, 8)

  isVisible         Boolean   @default(true)
  lastActiveAt      DateTime  @default(now())

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([verificationLevel])
  @@index([age])
  @@index([gender])
  @@index([isVisible])
}

// ==========================================
// EVENTS
// ==========================================

model Event {
  id              String    @id @default(cuid())

  name            String
  slug            String    @unique
  description     String?   @db.Text
  imageUrl        String?
  websiteUrl      String?

  eventType       EventType @default(OTHER)
  tags            String[]

  startDate       DateTime
  endDate         DateTime

  venueName       String?
  address         String?
  city            String
  country         String
  latitude        Decimal?  @db.Decimal(10, 8)
  longitude       Decimal?  @db.Decimal(11, 8)

  expectedAttendance Int?
  isActive        Boolean   @default(true)
  isFeatured      Boolean   @default(false)

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  attendances     EventAttendance[]
  accommodations  Accommodation[]
  matches         Match[]

  @@index([startDate])
  @@index([endDate])
  @@index([city])
  @@index([country])
  @@index([isActive])
  @@index([eventType])
}

model EventAttendance {
  id                  String    @id @default(cuid())

  userId              String
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  eventId             String
  event               Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)

  accommodationStatus AccommodationStatus @default(LOOKING)

  arrivalDate         DateTime?
  departureDate       DateTime?
  notes               String?   @db.Text

  accommodationId     String?
  accommodation       Accommodation? @relation(fields: [accommodationId], references: [id], onDelete: SetNull)

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
  @@index([accommodationStatus])
}

// ==========================================
// ACCOMMODATIONS
// ==========================================

model Accommodation {
  id              String    @id @default(cuid())

  ownerId         String
  owner           User      @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  eventId         String
  event           Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)

  title           String
  description     String?   @db.Text
  accommodationType AccommodationType @default(OTHER)

  totalSpots      Int       @default(1)
  availableSpots  Int       @default(1)

  costPerNight    Decimal?  @db.Decimal(10, 2)
  costTotal       Decimal?  @db.Decimal(10, 2)
  currency        String    @default("EUR")
  isCostSplit     Boolean   @default(true)

  amenities       String[]
  distanceToVenue String?
  address         String?
  photoUrls       String[]

  isActive        Boolean   @default(true)
  isVerified      Boolean   @default(false)

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  attendances     EventAttendance[]
  matches         Match[]

  @@index([ownerId])
  @@index([eventId])
  @@index([isActive])
  @@index([availableSpots])
}

// ==========================================
// MATCHING
// ==========================================

model Match {
  id              String    @id @default(cuid())

  initiatorId     String
  initiator       User      @relation("MatchInitiator", fields: [initiatorId], references: [id], onDelete: Cascade)

  receiverId      String
  receiver        User      @relation("MatchReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  eventId         String
  event           Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)

  accommodationId String?
  accommodation   Accommodation? @relation(fields: [accommodationId], references: [id], onDelete: SetNull)

  status          MatchStatus @default(PENDING)
  compatibilityScore  Decimal  @db.Decimal(5, 2)
  scoreBreakdown  Json?

  initiatorMessage String?   @db.Text
  initiatorAccepted Boolean  @default(true)
  receiverAccepted  Boolean?

  expiresAt       DateTime?
  respondedAt     DateTime?

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  messageThread   MessageThread?

  @@unique([initiatorId, receiverId, eventId])
  @@index([initiatorId])
  @@index([receiverId])
  @@index([eventId])
  @@index([status])
  @@index([compatibilityScore])
}

// ==========================================
// DEALBREAKERS
// ==========================================

model Dealbreaker {
  id              String    @id @default(cuid())

  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  category        String
  operator        String
  value           String

  isActive        Boolean   @default(true)

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([userId])
  @@index([category])
  @@index([isActive])
}

// ==========================================
// MESSAGING
// ==========================================

model MessageThread {
  id              String    @id @default(cuid())

  user1Id         String
  user1           User      @relation("ThreadUser1", fields: [user1Id], references: [id], onDelete: Cascade)

  user2Id         String
  user2           User      @relation("ThreadUser2", fields: [user2Id], references: [id], onDelete: Cascade)

  matchId         String?   @unique
  match           Match?    @relation(fields: [matchId], references: [id], onDelete: SetNull)

  lastMessageAt   DateTime  @default(now())
  isActive        Boolean   @default(true)

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  messages        Message[]

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
  @@index([lastMessageAt])
}

model Message {
  id              String    @id @default(cuid())

  threadId        String
  thread          MessageThread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  senderId        String
  sender          User      @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  content         String    @db.Text

  isRead          Boolean   @default(false)
  readAt          DateTime?

  isEdited        Boolean   @default(false)
  editedAt        DateTime?

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([threadId])
  @@index([senderId])
  @@index([isRead])
  @@index([createdAt])
}

// ==========================================
// SAFETY & TRUST
// ==========================================

model BlockedUser {
  id              String    @id @default(cuid())

  blockerId       String
  blocker         User      @relation("Blocker", fields: [blockerId], references: [id], onDelete: Cascade)

  blockedId       String
  blocked         User      @relation("Blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  reason          String?   @db.Text

  createdAt       DateTime  @default(now())

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
}

model Report {
  id              String    @id @default(cuid())

  reporterId      String
  reporter        User      @relation("Reporter", fields: [reporterId], references: [id], onDelete: Cascade)

  reportedId      String
  reported        User      @relation("Reported", fields: [reportedId], references: [id], onDelete: Cascade)

  reason          ReportReason
  description     String    @db.Text
  evidence        String[]

  status          ReportStatus @default(PENDING)

  handledById     String?
  handledAt       DateTime?
  resolution      String?   @db.Text

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([reporterId])
  @@index([reportedId])
  @@index([status])
  @@index([reason])
}

model Review {
  id              String    @id @default(cuid())

  reviewerId      String
  reviewer        User      @relation("Reviewer", fields: [reviewerId], references: [id], onDelete: Cascade)

  reviewedId      String
  reviewed        User      @relation("Reviewed", fields: [reviewedId], references: [id], onDelete: Cascade)

  overallRating   Int

  communicationRating Int?
  cleanlinessRating   Int?
  respectfulnessRating Int?

  content         String?   @db.Text
  eventContext    String?

  isVisible       Boolean   @default(true)
  isVerified      Boolean   @default(false)

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@unique([reviewerId, reviewedId])
  @@index([reviewerId])
  @@index([reviewedId])
  @@index([overallRating])
  @@index([isVisible])
}

model UserVerification {
  id              String    @id @default(cuid())

  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  type            VerificationLevel

  isVerified      Boolean   @default(false)
  verifiedAt      DateTime?

  evidenceUrl     String?
  provider        String?
  externalId      String?
  expiresAt       DateTime?

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@unique([userId, type])
  @@index([userId])
  @@index([type])
  @@index([isVerified])
}
